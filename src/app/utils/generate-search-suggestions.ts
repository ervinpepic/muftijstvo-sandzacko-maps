import { VakufMarkerDetails } from '../interface/Marker';
import { normalizeString } from './input-validators';

/**
 * Generates a list of search suggestions based on the user's search query and a list of filtered markers. This function 
 * normalizes both the search query and relevant marker properties (vakuf name and cadastral parcel number) to ensure 
 * consistent matching regardless of character variations. Suggestions are generated by checking if the normalized vakuf 
 * name or cadastral parcel number includes the normalized search query. Each unique suggestion is added to a set to 
 * avoid duplicates.
 *
 * The function attempts to enhance the search experience by allowing users to find markers not only by their names but 
 * also by cadastral parcel numbers, accommodating various search preferences. After collecting suggestions, they are 
 * converted to an array, sorted by relevance to the search query to improve the user's ability to quickly find the 
 * desired result.
 *
 * @param {VakufMarkerDetails[]} filteredMarkers - An array of markers that have been filtered based on some criteria, 
 *                                           providing a subset of markers to generate suggestions from.
 * @param {string} searchQuery - The user's input used to generate search suggestions. This query is normalized to 
 *                               ensure case and accent-insensitive matching.
 * @returns {string[]} An array of strings representing the search suggestions. These suggestions are sorted by 
 *                     their relevance to the search query to enhance usability.
 * @throws Will log an error to the console if an exception occurs during the generation of search suggestions.
 */
export function generateSearchSuggestions(
  filteredMarkers: VakufMarkerDetails[],
  searchQuery: string
): string[] {
  try {
    const suggestionsSet = new Set<string>();
    const normalizedSearchQuery = normalizeString(searchQuery); // Remove lowercase here

    filteredMarkers.forEach((marker) => {
      const normalizedVakufName = normalizeString(marker.vakufName); // Normalize vakufName here
      const normalizedCadastralParcelNumber = normalizeString(
        marker.cadastralParcelNumber
      ); // Normalize cadastralParcelNumber here

      if (normalizedVakufName.includes(normalizedSearchQuery)) {
        suggestionsSet.add(marker.vakufName);
      }

      if (normalizedCadastralParcelNumber.includes(normalizedSearchQuery)) {
        suggestionsSet.add(
          `${marker.cadastralParcelNumber} ${marker.vakufName}`
        );
      }
    });

    return Array.from(suggestionsSet).sort((a, b) =>
      calculateRelevance(a, b, normalizedSearchQuery)
    );
  } catch (error) {
    console.error('Error generating search suggestions:', error);
    return [];
  }
}

/**
 * Calculates the relevance of two strings to an input value, preferring matches closer to the start of the string.
 * @param {string} a - The first comparison string.
 * @param {string} b - The second comparison string.
 * @param {string} inputValue - The input value to compare against.
 * @returns {number} A number indicating the relative relevance of `a` compared to `b`.
 */
function calculateRelevance(a: string, b: string, inputValue: string): number {
  const indexA = a.toLowerCase().indexOf(inputValue.toLowerCase());
  const indexB = b.toLowerCase().indexOf(inputValue.toLowerCase());

  // Prioritize strings where the inputValue appears earlier
  if (indexA !== indexB) {
    return indexA - indexB;
  }

  // If the position of inputValue is the same in both strings, or not present in either, sort alphabetically
  return a.localeCompare(b);
}
