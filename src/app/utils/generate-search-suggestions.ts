import { Marker } from '../interface/Marker';
import { normalizeString } from './input-validators';

/**
 * Generates a list of search suggestions based on the user's search query and a list of filtered markers. This function
 * normalizes both the search query and relevant marker properties (vakuf name and cadastral parcel number) to ensure
 * consistent matching regardless of character variations. Suggestions are generated by checking if the normalized vakuf
 * name or cadastral parcel number includes the normalized search query. Each unique suggestion is added to a set to
 * avoid duplicates.
 *
 * The function attempts to enhance the search experience by allowing users to find markers not only by their names but
 * also by cadastral parcel numbers, accommodating various search preferences. After collecting suggestions, they are
 * converted to an array, sorted by relevance to the search query to improve the user's ability to quickly find the
 * desired result.
 *
 * @param {Marker[]} filteredMarkers - An array of markers that have been filtered based on some criteria,
 *                                           providing a subset of markers to generate suggestions from.
 * @param {string} searchQuery - The user's input used to generate search suggestions. This query is normalized to
 *                               ensure case and accent-insensitive matching.
 * @returns {string[]} An array of strings representing the search suggestions. These suggestions are sorted by
 *                     their relevance to the search query to enhance usability.
 * @throws Will log an error to the console if an exception occurs during the generation of search suggestions.
 */
export function generateSearchSuggestions(
  filteredMarkers: Marker[],
  searchQuery: string
): string[] {
  if (!searchQuery.trim()) return []; // Return early for empty queries

  try {
    const suggestionsSet = new Set<string>();
    const normalizedSearchQuery = normalizeString(searchQuery.trim());

    filteredMarkers.forEach((marker) => {
      const normalizedVakufName = marker.vakufName
        ? normalizeString(marker.vakufName)
        : '';
      const normalizedCadastralParcelNumber = marker.cadastralParcelNumber
        ? normalizeString(marker.cadastralParcelNumber)
        : '';

       // Add suggestions based on matching vakuf name or cadastral parcel number
       if (normalizedVakufName.includes(normalizedSearchQuery)) {
        suggestionsSet.add(marker.vakufName);
      }

      if (normalizedCadastralParcelNumber.includes(normalizedSearchQuery)) {
        suggestionsSet.add(
          `${marker.cadastralParcelNumber} ${marker.vakufName}`
        );
      }
    });

    return Array.from(suggestionsSet).sort((a, b) =>
      calculateRelevance(a, b, normalizedSearchQuery)
    );
  } catch (error) {
    console.error('Error generating search suggestions:', error);
    return [];
  }
}

/**
 * Calculates the relevance of two strings to an input value, preferring matches closer to the start of the string.
 * @param {string} a - The first comparison string.
 * @param {string} b - The second comparison string.
 * @param {string} inputValue - The input value to compare against.
 * @returns {number} A number indicating the relative relevance of `a` compared to `b`.
 */
function calculateRelevance(a: string, b: string, inputValue: string): number {
  const normalizedA = normalizeString(a);
  const normalizedB = normalizeString(b);

  // Exact match prioritization
  if (normalizedA === inputValue) return -1;
  if (normalizedB === inputValue) return 1;

  // Partial match position prioritization
  const indexA = normalizedA.indexOf(inputValue);
  const indexB = normalizedB.indexOf(inputValue);

  if (indexA !== indexB) {
    return indexA - indexB;
  }

  // Alphabetical fallback
  return normalizedA.localeCompare(normalizedB);
}
